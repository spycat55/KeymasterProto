// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.26.1
// source: message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "api.webrtc.v1";

export enum MsgKind {
  KIND_UNSPECIFIED = 0,
  KIND_ERROR = 1,
  KIND_WS_SIGNALING = 2,
  /**
   * KIND_FILE_DEMAND_REQUEST - KIND_RTC_FILE_QUOTE = 3;
   *   KIND_RTC_FILE_CONTENT = 4;
   */
  KIND_FILE_DEMAND_REQUEST = 10,
  /** KIND_FILE_DEMAND_BROADCAST - 文件需求广播 */
  KIND_FILE_DEMAND_BROADCAST = 11,
  /** KIND_FEE_POOL_CREATE - 费用池创建 */
  KIND_FEE_POOL_CREATE = 12,
  /** KIND_FEE_POOL_SIGN - 费用池签名 */
  KIND_FEE_POOL_SIGN = 13,
  /** KIND_FEE_POOL_BASE_TX - 发送基础交易 */
  KIND_FEE_POOL_BASE_TX = 14,
  /** KIND_FEE_POOL_UPDATE - 费用池更新 */
  KIND_FEE_POOL_UPDATE = 15,
  /** KIND_FEE_POOL_UPDATE_NOTIFY - 费用池更新通知（服务器发送给客户端） */
  KIND_FEE_POOL_UPDATE_NOTIFY = 16,
  /** KIND_FEE_POOL_CLOSE - 费用池关闭 */
  KIND_FEE_POOL_CLOSE = 17,
  /** KIND_FEE_POOL_STATUS_QUERY - 费用池状态查询 */
  KIND_FEE_POOL_STATUS_QUERY = 18,
  /** KIND_FEE_POOL_STATUS_RESPONSE - 费用池状态响应 */
  KIND_FEE_POOL_STATUS_RESPONSE = 19,
  UNRECOGNIZED = -1,
}

export function msgKindFromJSON(object: any): MsgKind {
  switch (object) {
    case 0:
    case "KIND_UNSPECIFIED":
      return MsgKind.KIND_UNSPECIFIED;
    case 1:
    case "KIND_ERROR":
      return MsgKind.KIND_ERROR;
    case 2:
    case "KIND_WS_SIGNALING":
      return MsgKind.KIND_WS_SIGNALING;
    case 10:
    case "KIND_FILE_DEMAND_REQUEST":
      return MsgKind.KIND_FILE_DEMAND_REQUEST;
    case 11:
    case "KIND_FILE_DEMAND_BROADCAST":
      return MsgKind.KIND_FILE_DEMAND_BROADCAST;
    case 12:
    case "KIND_FEE_POOL_CREATE":
      return MsgKind.KIND_FEE_POOL_CREATE;
    case 13:
    case "KIND_FEE_POOL_SIGN":
      return MsgKind.KIND_FEE_POOL_SIGN;
    case 14:
    case "KIND_FEE_POOL_BASE_TX":
      return MsgKind.KIND_FEE_POOL_BASE_TX;
    case 15:
    case "KIND_FEE_POOL_UPDATE":
      return MsgKind.KIND_FEE_POOL_UPDATE;
    case 16:
    case "KIND_FEE_POOL_UPDATE_NOTIFY":
      return MsgKind.KIND_FEE_POOL_UPDATE_NOTIFY;
    case 17:
    case "KIND_FEE_POOL_CLOSE":
      return MsgKind.KIND_FEE_POOL_CLOSE;
    case 18:
    case "KIND_FEE_POOL_STATUS_QUERY":
      return MsgKind.KIND_FEE_POOL_STATUS_QUERY;
    case 19:
    case "KIND_FEE_POOL_STATUS_RESPONSE":
      return MsgKind.KIND_FEE_POOL_STATUS_RESPONSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MsgKind.UNRECOGNIZED;
  }
}

export function msgKindToJSON(object: MsgKind): string {
  switch (object) {
    case MsgKind.KIND_UNSPECIFIED:
      return "KIND_UNSPECIFIED";
    case MsgKind.KIND_ERROR:
      return "KIND_ERROR";
    case MsgKind.KIND_WS_SIGNALING:
      return "KIND_WS_SIGNALING";
    case MsgKind.KIND_FILE_DEMAND_REQUEST:
      return "KIND_FILE_DEMAND_REQUEST";
    case MsgKind.KIND_FILE_DEMAND_BROADCAST:
      return "KIND_FILE_DEMAND_BROADCAST";
    case MsgKind.KIND_FEE_POOL_CREATE:
      return "KIND_FEE_POOL_CREATE";
    case MsgKind.KIND_FEE_POOL_SIGN:
      return "KIND_FEE_POOL_SIGN";
    case MsgKind.KIND_FEE_POOL_BASE_TX:
      return "KIND_FEE_POOL_BASE_TX";
    case MsgKind.KIND_FEE_POOL_UPDATE:
      return "KIND_FEE_POOL_UPDATE";
    case MsgKind.KIND_FEE_POOL_UPDATE_NOTIFY:
      return "KIND_FEE_POOL_UPDATE_NOTIFY";
    case MsgKind.KIND_FEE_POOL_CLOSE:
      return "KIND_FEE_POOL_CLOSE";
    case MsgKind.KIND_FEE_POOL_STATUS_QUERY:
      return "KIND_FEE_POOL_STATUS_QUERY";
    case MsgKind.KIND_FEE_POOL_STATUS_RESPONSE:
      return "KIND_FEE_POOL_STATUS_RESPONSE";
    case MsgKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Header {
  kind: MsgKind;
  /** 全局唯一 ID */
  messageId: string;
  /** 关联请求/响应 ID */
  correlationId: string;
  /** 发送时间 */
  ts?:
    | Date
    | undefined;
  /** 发送方公钥 */
  fromPubkey: Uint8Array;
  /** 接收方公钥 */
  toPubkey: Uint8Array;
}

export interface Envelope {
  /** 协议版本 */
  version: number;
  header?:
    | Header
    | undefined;
  /** 安全字段（必填） */
  signature: Uint8Array;
  /** 如 "ECDSA_P256_SHA256" */
  signatureAlgo: string;
  errorReply?: ErrorReply | undefined;
  wsSignaling?:
    | WSSignaling
    | undefined;
  /**
   * RTCFileQuote rtc_file_quote = 7;
   * RTCFileContent rtc_file_content = 8;
   */
  fileDemandRequest?: FileDemandRequest | undefined;
  fileDemandBroadcast?: FileDemandBroadcast | undefined;
  feePoolCreate?: FeePoolCreate | undefined;
  feePoolSign?: FeePoolSign | undefined;
  feePoolBaseTx?: FeePoolBaseTx | undefined;
  feePoolUpdate?: FeePoolUpdate | undefined;
  feePoolUpdateNotify?: FeePoolUpdateNotify | undefined;
  feePoolClose?: FeePoolClose | undefined;
  feePoolStatusQuery?: FeePoolStatusQuery | undefined;
  feePoolStatusResponse?: FeePoolStatusResponse | undefined;
}

export interface ErrorReply {
  /** 字符串形式的错误码 */
  errorCode: string;
  detail: string;
}

export interface WSSignaling {
  /** offer, candidate */
  signalingType: string;
  /** SDP / ICE / 其他 */
  data: Uint8Array;
}

/** 费用池创建消息 */
export interface FeePoolCreate {
  /** 花费交易 */
  spendTx: Uint8Array;
  /** 客户端签名 */
  clientSignature: Uint8Array;
}

/** 费用池签名消息 */
export interface FeePoolSign {
  /** 花费交易ID */
  spendTxid: Uint8Array;
  /** 服务器签名（为空表示拒绝） */
  serverSignature: Uint8Array;
  /** 错误信息（为空表示批准） */
  errorMessage: string;
}

/** 发送基础交易消息 */
export interface FeePoolBaseTx {
  /** 基础交易 */
  baseTx: Uint8Array;
  /** 客户端对基础交易的签名 */
  clientSignature: Uint8Array;
}

/** 费用池更新通知消息（服务器发送给客户端） */
export interface FeePoolUpdateNotify {
  /** 基础交易ID */
  baseTxid: Uint8Array;
  /** 序列号 */
  sequenceNumber: number;
  /** 服务器金额 */
  serverAmount: number;
  /** 交易费用 */
  fee: number;
}

/** 费用池更新消息（客户端发送给服务器） */
export interface FeePoolUpdate {
  /** 基础交易ID */
  baseTxid: Uint8Array;
  /** 花费交易ID */
  spendTxid: Uint8Array;
  /** 客户端对花费交易的签名 */
  clientSignature: Uint8Array;
  /** 操作类型：update, close */
  operationType: string;
}

/** 费用池关闭消息 */
export interface FeePoolClose {
  /** 基础交易ID */
  baseTxid: Uint8Array;
  /** 服务器金额 */
  serverAmount: number;
  /** 交易费用 */
  fee: number;
}

/** 费用池状态查询消息 */
export interface FeePoolStatusQuery {
  /** 基础交易ID（可选，为空则查询客户端所有费用池） */
  baseTxid: Uint8Array;
}

/** 费用池状态响应消息 */
export interface FeePoolStatusResponse {
  /** 基础交易ID */
  baseTxid: Uint8Array;
  /** 状态：pending, signed, active, expired, closed, error */
  status: string;
  /** 服务器当前金额 */
  serverAmount: number;
  /** 客户端剩余金额 */
  clientAmount: number;
  /** 当前序列号 */
  sequenceNumber: number;
  /** 创建时间 */
  createdAt?:
    | Date
    | undefined;
  /** 过期时间（如果适用） */
  expiresAt?:
    | Date
    | undefined;
  /** 错误原因（状态为error时） */
  errorReason: string;
}

/** 文件需求请求消息 */
export interface FileDemandRequest {
  /** 文件哈希 */
  fileHash: Uint8Array;
}

/** 文件需求广播消息 */
export interface FileDemandBroadcast {
  /** 文件哈希 */
  fileHash: Uint8Array;
}

function createBaseHeader(): Header {
  return {
    kind: 0,
    messageId: "",
    correlationId: "",
    ts: undefined,
    fromPubkey: new Uint8Array(0),
    toPubkey: new Uint8Array(0),
  };
}

export const Header: MessageFns<Header> = {
  encode(message: Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.correlationId !== "") {
      writer.uint32(26).string(message.correlationId);
    }
    if (message.ts !== undefined) {
      Timestamp.encode(toTimestamp(message.ts), writer.uint32(34).fork()).join();
    }
    if (message.fromPubkey.length !== 0) {
      writer.uint32(42).bytes(message.fromPubkey);
    }
    if (message.toPubkey.length !== 0) {
      writer.uint32(50).bytes(message.toPubkey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ts = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromPubkey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toPubkey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Header {
    return {
      kind: isSet(object.kind) ? msgKindFromJSON(object.kind) : 0,
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      ts: isSet(object.ts) ? fromJsonTimestamp(object.ts) : undefined,
      fromPubkey: isSet(object.fromPubkey) ? bytesFromBase64(object.fromPubkey) : new Uint8Array(0),
      toPubkey: isSet(object.toPubkey) ? bytesFromBase64(object.toPubkey) : new Uint8Array(0),
    };
  },

  toJSON(message: Header): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = msgKindToJSON(message.kind);
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.ts !== undefined) {
      obj.ts = message.ts.toISOString();
    }
    if (message.fromPubkey.length !== 0) {
      obj.fromPubkey = base64FromBytes(message.fromPubkey);
    }
    if (message.toPubkey.length !== 0) {
      obj.toPubkey = base64FromBytes(message.toPubkey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Header>, I>>(base?: I): Header {
    return Header.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Header>, I>>(object: I): Header {
    const message = createBaseHeader();
    message.kind = object.kind ?? 0;
    message.messageId = object.messageId ?? "";
    message.correlationId = object.correlationId ?? "";
    message.ts = object.ts ?? undefined;
    message.fromPubkey = object.fromPubkey ?? new Uint8Array(0);
    message.toPubkey = object.toPubkey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEnvelope(): Envelope {
  return {
    version: 0,
    header: undefined,
    signature: new Uint8Array(0),
    signatureAlgo: "",
    errorReply: undefined,
    wsSignaling: undefined,
    fileDemandRequest: undefined,
    fileDemandBroadcast: undefined,
    feePoolCreate: undefined,
    feePoolSign: undefined,
    feePoolBaseTx: undefined,
    feePoolUpdate: undefined,
    feePoolUpdateNotify: undefined,
    feePoolClose: undefined,
    feePoolStatusQuery: undefined,
    feePoolStatusResponse: undefined,
  };
}

export const Envelope: MessageFns<Envelope> = {
  encode(message: Envelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.header !== undefined) {
      Header.encode(message.header, writer.uint32(18).fork()).join();
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    if (message.signatureAlgo !== "") {
      writer.uint32(34).string(message.signatureAlgo);
    }
    if (message.errorReply !== undefined) {
      ErrorReply.encode(message.errorReply, writer.uint32(42).fork()).join();
    }
    if (message.wsSignaling !== undefined) {
      WSSignaling.encode(message.wsSignaling, writer.uint32(50).fork()).join();
    }
    if (message.fileDemandRequest !== undefined) {
      FileDemandRequest.encode(message.fileDemandRequest, writer.uint32(82).fork()).join();
    }
    if (message.fileDemandBroadcast !== undefined) {
      FileDemandBroadcast.encode(message.fileDemandBroadcast, writer.uint32(90).fork()).join();
    }
    if (message.feePoolCreate !== undefined) {
      FeePoolCreate.encode(message.feePoolCreate, writer.uint32(98).fork()).join();
    }
    if (message.feePoolSign !== undefined) {
      FeePoolSign.encode(message.feePoolSign, writer.uint32(106).fork()).join();
    }
    if (message.feePoolBaseTx !== undefined) {
      FeePoolBaseTx.encode(message.feePoolBaseTx, writer.uint32(114).fork()).join();
    }
    if (message.feePoolUpdate !== undefined) {
      FeePoolUpdate.encode(message.feePoolUpdate, writer.uint32(122).fork()).join();
    }
    if (message.feePoolUpdateNotify !== undefined) {
      FeePoolUpdateNotify.encode(message.feePoolUpdateNotify, writer.uint32(130).fork()).join();
    }
    if (message.feePoolClose !== undefined) {
      FeePoolClose.encode(message.feePoolClose, writer.uint32(138).fork()).join();
    }
    if (message.feePoolStatusQuery !== undefined) {
      FeePoolStatusQuery.encode(message.feePoolStatusQuery, writer.uint32(146).fork()).join();
    }
    if (message.feePoolStatusResponse !== undefined) {
      FeePoolStatusResponse.encode(message.feePoolStatusResponse, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.header = Header.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signatureAlgo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorReply = ErrorReply.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.wsSignaling = WSSignaling.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fileDemandRequest = FileDemandRequest.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.fileDemandBroadcast = FileDemandBroadcast.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.feePoolCreate = FeePoolCreate.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.feePoolSign = FeePoolSign.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.feePoolBaseTx = FeePoolBaseTx.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.feePoolUpdate = FeePoolUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.feePoolUpdateNotify = FeePoolUpdateNotify.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.feePoolClose = FeePoolClose.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.feePoolStatusQuery = FeePoolStatusQuery.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.feePoolStatusResponse = FeePoolStatusResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Envelope {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      header: isSet(object.header) ? Header.fromJSON(object.header) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      signatureAlgo: isSet(object.signatureAlgo) ? globalThis.String(object.signatureAlgo) : "",
      errorReply: isSet(object.errorReply) ? ErrorReply.fromJSON(object.errorReply) : undefined,
      wsSignaling: isSet(object.wsSignaling) ? WSSignaling.fromJSON(object.wsSignaling) : undefined,
      fileDemandRequest: isSet(object.fileDemandRequest)
        ? FileDemandRequest.fromJSON(object.fileDemandRequest)
        : undefined,
      fileDemandBroadcast: isSet(object.fileDemandBroadcast)
        ? FileDemandBroadcast.fromJSON(object.fileDemandBroadcast)
        : undefined,
      feePoolCreate: isSet(object.feePoolCreate) ? FeePoolCreate.fromJSON(object.feePoolCreate) : undefined,
      feePoolSign: isSet(object.feePoolSign) ? FeePoolSign.fromJSON(object.feePoolSign) : undefined,
      feePoolBaseTx: isSet(object.feePoolBaseTx) ? FeePoolBaseTx.fromJSON(object.feePoolBaseTx) : undefined,
      feePoolUpdate: isSet(object.feePoolUpdate) ? FeePoolUpdate.fromJSON(object.feePoolUpdate) : undefined,
      feePoolUpdateNotify: isSet(object.feePoolUpdateNotify)
        ? FeePoolUpdateNotify.fromJSON(object.feePoolUpdateNotify)
        : undefined,
      feePoolClose: isSet(object.feePoolClose) ? FeePoolClose.fromJSON(object.feePoolClose) : undefined,
      feePoolStatusQuery: isSet(object.feePoolStatusQuery)
        ? FeePoolStatusQuery.fromJSON(object.feePoolStatusQuery)
        : undefined,
      feePoolStatusResponse: isSet(object.feePoolStatusResponse)
        ? FeePoolStatusResponse.fromJSON(object.feePoolStatusResponse)
        : undefined,
    };
  },

  toJSON(message: Envelope): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.header !== undefined) {
      obj.header = Header.toJSON(message.header);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.signatureAlgo !== "") {
      obj.signatureAlgo = message.signatureAlgo;
    }
    if (message.errorReply !== undefined) {
      obj.errorReply = ErrorReply.toJSON(message.errorReply);
    }
    if (message.wsSignaling !== undefined) {
      obj.wsSignaling = WSSignaling.toJSON(message.wsSignaling);
    }
    if (message.fileDemandRequest !== undefined) {
      obj.fileDemandRequest = FileDemandRequest.toJSON(message.fileDemandRequest);
    }
    if (message.fileDemandBroadcast !== undefined) {
      obj.fileDemandBroadcast = FileDemandBroadcast.toJSON(message.fileDemandBroadcast);
    }
    if (message.feePoolCreate !== undefined) {
      obj.feePoolCreate = FeePoolCreate.toJSON(message.feePoolCreate);
    }
    if (message.feePoolSign !== undefined) {
      obj.feePoolSign = FeePoolSign.toJSON(message.feePoolSign);
    }
    if (message.feePoolBaseTx !== undefined) {
      obj.feePoolBaseTx = FeePoolBaseTx.toJSON(message.feePoolBaseTx);
    }
    if (message.feePoolUpdate !== undefined) {
      obj.feePoolUpdate = FeePoolUpdate.toJSON(message.feePoolUpdate);
    }
    if (message.feePoolUpdateNotify !== undefined) {
      obj.feePoolUpdateNotify = FeePoolUpdateNotify.toJSON(message.feePoolUpdateNotify);
    }
    if (message.feePoolClose !== undefined) {
      obj.feePoolClose = FeePoolClose.toJSON(message.feePoolClose);
    }
    if (message.feePoolStatusQuery !== undefined) {
      obj.feePoolStatusQuery = FeePoolStatusQuery.toJSON(message.feePoolStatusQuery);
    }
    if (message.feePoolStatusResponse !== undefined) {
      obj.feePoolStatusResponse = FeePoolStatusResponse.toJSON(message.feePoolStatusResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Envelope>, I>>(base?: I): Envelope {
    return Envelope.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Envelope>, I>>(object: I): Envelope {
    const message = createBaseEnvelope();
    message.version = object.version ?? 0;
    message.header = (object.header !== undefined && object.header !== null)
      ? Header.fromPartial(object.header)
      : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    message.signatureAlgo = object.signatureAlgo ?? "";
    message.errorReply = (object.errorReply !== undefined && object.errorReply !== null)
      ? ErrorReply.fromPartial(object.errorReply)
      : undefined;
    message.wsSignaling = (object.wsSignaling !== undefined && object.wsSignaling !== null)
      ? WSSignaling.fromPartial(object.wsSignaling)
      : undefined;
    message.fileDemandRequest = (object.fileDemandRequest !== undefined && object.fileDemandRequest !== null)
      ? FileDemandRequest.fromPartial(object.fileDemandRequest)
      : undefined;
    message.fileDemandBroadcast = (object.fileDemandBroadcast !== undefined && object.fileDemandBroadcast !== null)
      ? FileDemandBroadcast.fromPartial(object.fileDemandBroadcast)
      : undefined;
    message.feePoolCreate = (object.feePoolCreate !== undefined && object.feePoolCreate !== null)
      ? FeePoolCreate.fromPartial(object.feePoolCreate)
      : undefined;
    message.feePoolSign = (object.feePoolSign !== undefined && object.feePoolSign !== null)
      ? FeePoolSign.fromPartial(object.feePoolSign)
      : undefined;
    message.feePoolBaseTx = (object.feePoolBaseTx !== undefined && object.feePoolBaseTx !== null)
      ? FeePoolBaseTx.fromPartial(object.feePoolBaseTx)
      : undefined;
    message.feePoolUpdate = (object.feePoolUpdate !== undefined && object.feePoolUpdate !== null)
      ? FeePoolUpdate.fromPartial(object.feePoolUpdate)
      : undefined;
    message.feePoolUpdateNotify = (object.feePoolUpdateNotify !== undefined && object.feePoolUpdateNotify !== null)
      ? FeePoolUpdateNotify.fromPartial(object.feePoolUpdateNotify)
      : undefined;
    message.feePoolClose = (object.feePoolClose !== undefined && object.feePoolClose !== null)
      ? FeePoolClose.fromPartial(object.feePoolClose)
      : undefined;
    message.feePoolStatusQuery = (object.feePoolStatusQuery !== undefined && object.feePoolStatusQuery !== null)
      ? FeePoolStatusQuery.fromPartial(object.feePoolStatusQuery)
      : undefined;
    message.feePoolStatusResponse =
      (object.feePoolStatusResponse !== undefined && object.feePoolStatusResponse !== null)
        ? FeePoolStatusResponse.fromPartial(object.feePoolStatusResponse)
        : undefined;
    return message;
  },
};

function createBaseErrorReply(): ErrorReply {
  return { errorCode: "", detail: "" };
}

export const ErrorReply: MessageFns<ErrorReply> = {
  encode(message: ErrorReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.detail !== "") {
      writer.uint32(18).string(message.detail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorReply {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
    };
  },

  toJSON(message: ErrorReply): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorReply>, I>>(base?: I): ErrorReply {
    return ErrorReply.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorReply>, I>>(object: I): ErrorReply {
    const message = createBaseErrorReply();
    message.errorCode = object.errorCode ?? "";
    message.detail = object.detail ?? "";
    return message;
  },
};

function createBaseWSSignaling(): WSSignaling {
  return { signalingType: "", data: new Uint8Array(0) };
}

export const WSSignaling: MessageFns<WSSignaling> = {
  encode(message: WSSignaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signalingType !== "") {
      writer.uint32(10).string(message.signalingType);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WSSignaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWSSignaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signalingType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WSSignaling {
    return {
      signalingType: isSet(object.signalingType) ? globalThis.String(object.signalingType) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: WSSignaling): unknown {
    const obj: any = {};
    if (message.signalingType !== "") {
      obj.signalingType = message.signalingType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WSSignaling>, I>>(base?: I): WSSignaling {
    return WSSignaling.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WSSignaling>, I>>(object: I): WSSignaling {
    const message = createBaseWSSignaling();
    message.signalingType = object.signalingType ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFeePoolCreate(): FeePoolCreate {
  return { spendTx: new Uint8Array(0), clientSignature: new Uint8Array(0) };
}

export const FeePoolCreate: MessageFns<FeePoolCreate> = {
  encode(message: FeePoolCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spendTx.length !== 0) {
      writer.uint32(10).bytes(message.spendTx);
    }
    if (message.clientSignature.length !== 0) {
      writer.uint32(18).bytes(message.clientSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spendTx = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolCreate {
    return {
      spendTx: isSet(object.spendTx) ? bytesFromBase64(object.spendTx) : new Uint8Array(0),
      clientSignature: isSet(object.clientSignature) ? bytesFromBase64(object.clientSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: FeePoolCreate): unknown {
    const obj: any = {};
    if (message.spendTx.length !== 0) {
      obj.spendTx = base64FromBytes(message.spendTx);
    }
    if (message.clientSignature.length !== 0) {
      obj.clientSignature = base64FromBytes(message.clientSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolCreate>, I>>(base?: I): FeePoolCreate {
    return FeePoolCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolCreate>, I>>(object: I): FeePoolCreate {
    const message = createBaseFeePoolCreate();
    message.spendTx = object.spendTx ?? new Uint8Array(0);
    message.clientSignature = object.clientSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFeePoolSign(): FeePoolSign {
  return { spendTxid: new Uint8Array(0), serverSignature: new Uint8Array(0), errorMessage: "" };
}

export const FeePoolSign: MessageFns<FeePoolSign> = {
  encode(message: FeePoolSign, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spendTxid.length !== 0) {
      writer.uint32(10).bytes(message.spendTxid);
    }
    if (message.serverSignature.length !== 0) {
      writer.uint32(18).bytes(message.serverSignature);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolSign {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolSign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.spendTxid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serverSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolSign {
    return {
      spendTxid: isSet(object.spendTxid) ? bytesFromBase64(object.spendTxid) : new Uint8Array(0),
      serverSignature: isSet(object.serverSignature) ? bytesFromBase64(object.serverSignature) : new Uint8Array(0),
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: FeePoolSign): unknown {
    const obj: any = {};
    if (message.spendTxid.length !== 0) {
      obj.spendTxid = base64FromBytes(message.spendTxid);
    }
    if (message.serverSignature.length !== 0) {
      obj.serverSignature = base64FromBytes(message.serverSignature);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolSign>, I>>(base?: I): FeePoolSign {
    return FeePoolSign.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolSign>, I>>(object: I): FeePoolSign {
    const message = createBaseFeePoolSign();
    message.spendTxid = object.spendTxid ?? new Uint8Array(0);
    message.serverSignature = object.serverSignature ?? new Uint8Array(0);
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseFeePoolBaseTx(): FeePoolBaseTx {
  return { baseTx: new Uint8Array(0), clientSignature: new Uint8Array(0) };
}

export const FeePoolBaseTx: MessageFns<FeePoolBaseTx> = {
  encode(message: FeePoolBaseTx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTx.length !== 0) {
      writer.uint32(10).bytes(message.baseTx);
    }
    if (message.clientSignature.length !== 0) {
      writer.uint32(18).bytes(message.clientSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolBaseTx {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolBaseTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseTx = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolBaseTx {
    return {
      baseTx: isSet(object.baseTx) ? bytesFromBase64(object.baseTx) : new Uint8Array(0),
      clientSignature: isSet(object.clientSignature) ? bytesFromBase64(object.clientSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: FeePoolBaseTx): unknown {
    const obj: any = {};
    if (message.baseTx.length !== 0) {
      obj.baseTx = base64FromBytes(message.baseTx);
    }
    if (message.clientSignature.length !== 0) {
      obj.clientSignature = base64FromBytes(message.clientSignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolBaseTx>, I>>(base?: I): FeePoolBaseTx {
    return FeePoolBaseTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolBaseTx>, I>>(object: I): FeePoolBaseTx {
    const message = createBaseFeePoolBaseTx();
    message.baseTx = object.baseTx ?? new Uint8Array(0);
    message.clientSignature = object.clientSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFeePoolUpdateNotify(): FeePoolUpdateNotify {
  return { baseTxid: new Uint8Array(0), sequenceNumber: 0, serverAmount: 0, fee: 0 };
}

export const FeePoolUpdateNotify: MessageFns<FeePoolUpdateNotify> = {
  encode(message: FeePoolUpdateNotify, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTxid.length !== 0) {
      writer.uint32(10).bytes(message.baseTxid);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(16).uint32(message.sequenceNumber);
    }
    if (message.serverAmount !== 0) {
      writer.uint32(24).uint64(message.serverAmount);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolUpdateNotify {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolUpdateNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseTxid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.serverAmount = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolUpdateNotify {
    return {
      baseTxid: isSet(object.baseTxid) ? bytesFromBase64(object.baseTxid) : new Uint8Array(0),
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
      serverAmount: isSet(object.serverAmount) ? globalThis.Number(object.serverAmount) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
    };
  },

  toJSON(message: FeePoolUpdateNotify): unknown {
    const obj: any = {};
    if (message.baseTxid.length !== 0) {
      obj.baseTxid = base64FromBytes(message.baseTxid);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    if (message.serverAmount !== 0) {
      obj.serverAmount = Math.round(message.serverAmount);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolUpdateNotify>, I>>(base?: I): FeePoolUpdateNotify {
    return FeePoolUpdateNotify.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolUpdateNotify>, I>>(object: I): FeePoolUpdateNotify {
    const message = createBaseFeePoolUpdateNotify();
    message.baseTxid = object.baseTxid ?? new Uint8Array(0);
    message.sequenceNumber = object.sequenceNumber ?? 0;
    message.serverAmount = object.serverAmount ?? 0;
    message.fee = object.fee ?? 0;
    return message;
  },
};

function createBaseFeePoolUpdate(): FeePoolUpdate {
  return {
    baseTxid: new Uint8Array(0),
    spendTxid: new Uint8Array(0),
    clientSignature: new Uint8Array(0),
    operationType: "",
  };
}

export const FeePoolUpdate: MessageFns<FeePoolUpdate> = {
  encode(message: FeePoolUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTxid.length !== 0) {
      writer.uint32(10).bytes(message.baseTxid);
    }
    if (message.spendTxid.length !== 0) {
      writer.uint32(18).bytes(message.spendTxid);
    }
    if (message.clientSignature.length !== 0) {
      writer.uint32(26).bytes(message.clientSignature);
    }
    if (message.operationType !== "") {
      writer.uint32(34).string(message.operationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseTxid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spendTxid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientSignature = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.operationType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolUpdate {
    return {
      baseTxid: isSet(object.baseTxid) ? bytesFromBase64(object.baseTxid) : new Uint8Array(0),
      spendTxid: isSet(object.spendTxid) ? bytesFromBase64(object.spendTxid) : new Uint8Array(0),
      clientSignature: isSet(object.clientSignature) ? bytesFromBase64(object.clientSignature) : new Uint8Array(0),
      operationType: isSet(object.operationType) ? globalThis.String(object.operationType) : "",
    };
  },

  toJSON(message: FeePoolUpdate): unknown {
    const obj: any = {};
    if (message.baseTxid.length !== 0) {
      obj.baseTxid = base64FromBytes(message.baseTxid);
    }
    if (message.spendTxid.length !== 0) {
      obj.spendTxid = base64FromBytes(message.spendTxid);
    }
    if (message.clientSignature.length !== 0) {
      obj.clientSignature = base64FromBytes(message.clientSignature);
    }
    if (message.operationType !== "") {
      obj.operationType = message.operationType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolUpdate>, I>>(base?: I): FeePoolUpdate {
    return FeePoolUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolUpdate>, I>>(object: I): FeePoolUpdate {
    const message = createBaseFeePoolUpdate();
    message.baseTxid = object.baseTxid ?? new Uint8Array(0);
    message.spendTxid = object.spendTxid ?? new Uint8Array(0);
    message.clientSignature = object.clientSignature ?? new Uint8Array(0);
    message.operationType = object.operationType ?? "";
    return message;
  },
};

function createBaseFeePoolClose(): FeePoolClose {
  return { baseTxid: new Uint8Array(0), serverAmount: 0, fee: 0 };
}

export const FeePoolClose: MessageFns<FeePoolClose> = {
  encode(message: FeePoolClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTxid.length !== 0) {
      writer.uint32(10).bytes(message.baseTxid);
    }
    if (message.serverAmount !== 0) {
      writer.uint32(16).uint64(message.serverAmount);
    }
    if (message.fee !== 0) {
      writer.uint32(24).uint64(message.fee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseTxid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.serverAmount = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fee = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolClose {
    return {
      baseTxid: isSet(object.baseTxid) ? bytesFromBase64(object.baseTxid) : new Uint8Array(0),
      serverAmount: isSet(object.serverAmount) ? globalThis.Number(object.serverAmount) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
    };
  },

  toJSON(message: FeePoolClose): unknown {
    const obj: any = {};
    if (message.baseTxid.length !== 0) {
      obj.baseTxid = base64FromBytes(message.baseTxid);
    }
    if (message.serverAmount !== 0) {
      obj.serverAmount = Math.round(message.serverAmount);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolClose>, I>>(base?: I): FeePoolClose {
    return FeePoolClose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolClose>, I>>(object: I): FeePoolClose {
    const message = createBaseFeePoolClose();
    message.baseTxid = object.baseTxid ?? new Uint8Array(0);
    message.serverAmount = object.serverAmount ?? 0;
    message.fee = object.fee ?? 0;
    return message;
  },
};

function createBaseFeePoolStatusQuery(): FeePoolStatusQuery {
  return { baseTxid: new Uint8Array(0) };
}

export const FeePoolStatusQuery: MessageFns<FeePoolStatusQuery> = {
  encode(message: FeePoolStatusQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTxid.length !== 0) {
      writer.uint32(10).bytes(message.baseTxid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolStatusQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolStatusQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseTxid = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolStatusQuery {
    return { baseTxid: isSet(object.baseTxid) ? bytesFromBase64(object.baseTxid) : new Uint8Array(0) };
  },

  toJSON(message: FeePoolStatusQuery): unknown {
    const obj: any = {};
    if (message.baseTxid.length !== 0) {
      obj.baseTxid = base64FromBytes(message.baseTxid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolStatusQuery>, I>>(base?: I): FeePoolStatusQuery {
    return FeePoolStatusQuery.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolStatusQuery>, I>>(object: I): FeePoolStatusQuery {
    const message = createBaseFeePoolStatusQuery();
    message.baseTxid = object.baseTxid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFeePoolStatusResponse(): FeePoolStatusResponse {
  return {
    baseTxid: new Uint8Array(0),
    status: "",
    serverAmount: 0,
    clientAmount: 0,
    sequenceNumber: 0,
    createdAt: undefined,
    expiresAt: undefined,
    errorReason: "",
  };
}

export const FeePoolStatusResponse: MessageFns<FeePoolStatusResponse> = {
  encode(message: FeePoolStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTxid.length !== 0) {
      writer.uint32(10).bytes(message.baseTxid);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.serverAmount !== 0) {
      writer.uint32(24).uint64(message.serverAmount);
    }
    if (message.clientAmount !== 0) {
      writer.uint32(32).uint64(message.clientAmount);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(40).uint32(message.sequenceNumber);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(58).fork()).join();
    }
    if (message.errorReason !== "") {
      writer.uint32(66).string(message.errorReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeePoolStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeePoolStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseTxid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.serverAmount = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.clientAmount = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.errorReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeePoolStatusResponse {
    return {
      baseTxid: isSet(object.baseTxid) ? bytesFromBase64(object.baseTxid) : new Uint8Array(0),
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      serverAmount: isSet(object.serverAmount) ? globalThis.Number(object.serverAmount) : 0,
      clientAmount: isSet(object.clientAmount) ? globalThis.Number(object.clientAmount) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      errorReason: isSet(object.errorReason) ? globalThis.String(object.errorReason) : "",
    };
  },

  toJSON(message: FeePoolStatusResponse): unknown {
    const obj: any = {};
    if (message.baseTxid.length !== 0) {
      obj.baseTxid = base64FromBytes(message.baseTxid);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.serverAmount !== 0) {
      obj.serverAmount = Math.round(message.serverAmount);
    }
    if (message.clientAmount !== 0) {
      obj.clientAmount = Math.round(message.clientAmount);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.errorReason !== "") {
      obj.errorReason = message.errorReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeePoolStatusResponse>, I>>(base?: I): FeePoolStatusResponse {
    return FeePoolStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeePoolStatusResponse>, I>>(object: I): FeePoolStatusResponse {
    const message = createBaseFeePoolStatusResponse();
    message.baseTxid = object.baseTxid ?? new Uint8Array(0);
    message.status = object.status ?? "";
    message.serverAmount = object.serverAmount ?? 0;
    message.clientAmount = object.clientAmount ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.errorReason = object.errorReason ?? "";
    return message;
  },
};

function createBaseFileDemandRequest(): FileDemandRequest {
  return { fileHash: new Uint8Array(0) };
}

export const FileDemandRequest: MessageFns<FileDemandRequest> = {
  encode(message: FileDemandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileHash.length !== 0) {
      writer.uint32(10).bytes(message.fileHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDemandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDemandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDemandRequest {
    return { fileHash: isSet(object.fileHash) ? bytesFromBase64(object.fileHash) : new Uint8Array(0) };
  },

  toJSON(message: FileDemandRequest): unknown {
    const obj: any = {};
    if (message.fileHash.length !== 0) {
      obj.fileHash = base64FromBytes(message.fileHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileDemandRequest>, I>>(base?: I): FileDemandRequest {
    return FileDemandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileDemandRequest>, I>>(object: I): FileDemandRequest {
    const message = createBaseFileDemandRequest();
    message.fileHash = object.fileHash ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFileDemandBroadcast(): FileDemandBroadcast {
  return { fileHash: new Uint8Array(0) };
}

export const FileDemandBroadcast: MessageFns<FileDemandBroadcast> = {
  encode(message: FileDemandBroadcast, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileHash.length !== 0) {
      writer.uint32(10).bytes(message.fileHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDemandBroadcast {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDemandBroadcast();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileHash = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDemandBroadcast {
    return { fileHash: isSet(object.fileHash) ? bytesFromBase64(object.fileHash) : new Uint8Array(0) };
  },

  toJSON(message: FileDemandBroadcast): unknown {
    const obj: any = {};
    if (message.fileHash.length !== 0) {
      obj.fileHash = base64FromBytes(message.fileHash);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileDemandBroadcast>, I>>(base?: I): FileDemandBroadcast {
    return FileDemandBroadcast.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileDemandBroadcast>, I>>(object: I): FileDemandBroadcast {
    const message = createBaseFileDemandBroadcast();
    message.fileHash = object.fileHash ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
